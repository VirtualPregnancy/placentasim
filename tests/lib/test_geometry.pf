@Test
   subroutine test_define_node_geometry()
      use pfunit_mod
      use arrays,only: dp,node_xyz,num_nodes,nodes
      use geometry,only: define_node_geometry	
      use other_consts, only: MAX_FILENAME_LEN
      use indices, only: perfusion_indices
      implicit none
      
      character(len=MAX_FILENAME_LEN) :: NODEFILE
      character(len=20) :: tree_type
      real(dp) :: test_node_xyz(3,4) ! (3:num_nodes)
      integer :: test_nodes(4) !num_nodes

      NODEFILE = ""
      call write_node_file(NODEFILE)

      !set up indices
      call perfusion_indices()
      !call the subroutine with the test node file
      call define_node_geometry(NODEFILE)
      
      !populate test variables - variables populated by define_node_geometry

      call set_nodes(test_nodes)
      call set_node_xyz(test_node_xyz)  
     
      @assertEqual(4, num_nodes)
      @assertEqual(test_nodes, nodes)
      @assertEqual(test_node_xyz,node_xyz)
      
      call delete_node_file(NODEFILE) 

   end subroutine test_define_node_geometry

! subroutines which populate test data
 subroutine write_node_file(NODEFILE)  
    use other_consts, only: MAX_FILENAME_LEN
    character(len=MAX_FILENAME_LEN), intent(out) :: NODEFILE
    NODEFILE = "test.ipnode"
    open(10, file=NODEFILE, status="replace")
    write(10,*) 'CMISS Version 2.1  ipnode File Version 2'
    write(10,*) 'Heading:'
    write(10,*) 'The number of nodes is [ 61742]:  4'
    write(10,*) 'Number of coordinates [3]: 3'
    write(10,*) 'Do you want prompting for different versions of nj=1 [N]? Y'
    write(10,*) 'Do you want prompting for different versions of nj=2 [N]? Y'
    write(10,*) 'Do you want prompting for different versions of nj=3 [N]? Y'
    write(10,*) 'The number of derivatives for coordinate 1 is [0]: 0'
    write(10,*) 'The number of derivatives for coordinate 2 is [0]: 0'
    write(10,*) 'The number of derivatives for coordinate 3 is [0]: 0'
    write(10,*) 'Node number [  1001]:   1'
    write(10,*) 'The number of versions for nj=1 is [1]:  1'
    write(10,*) 'The Xj(1) coordinate is [ 0.00000E+00]:   0.00'
    write(10,*) 'The number of versions for nj=2 is [1]:  1'
    write(10,*) 'The Xj(2) coordinate is [ 0.00000E+00]:   0.00'
    write(10,*) 'The number of versions for nj=3 is [1]:  1'
    write(10,*) 'The Xj(3) coordinate is [ 0.00000E+00]:   0.00'
    write(10,*) ''
    write(10,*) 'Node number [  1002]:   2'
    write(10,*) 'The number of versions for nj=1 is [1]:  1'
    write(10,*) 'The Xj(1) coordinate is [-0.15641E+03]:   0.00'
    write(10,*) 'The number of versions for nj=2 is [1]:  1'
    write(10,*) 'The Xj(2) coordinate is [-0.10446E+03]:   0.00'
    write(10,*) 'The number of versions for nj=3 is [1]:  1'
    write(10,*) 'The Xj(3) coordinate is [-0.12000E+01]:   -100.00'
    write(10,*) ''
    write(10,*) 'Node number [  1003]:   3'
    write(10,*) 'The number of versions for nj=1 is [1]:  1'
    write(10,*) 'The Xj(1) coordinate is [-0.15641E+03]:   0.00'
    write(10,*) 'The number of versions for nj=2 is [1]:  1'
    write(10,*) 'The Xj(2) coordinate is [-0.14300E+03]:   -50.00'
    write(10,*) 'The number of versions for nj=3 is [1]:  1'
    write(10,*) 'The Xj(3) coordinate is [-0.76198E+02]:   -150.00'
    write(10,*) ''
    write(10,*) 'Node number [  1004]:   4'
    write(10,*) 'The number of versions for nj=1 is [1]:  1'
    write(10,*) 'The Xj(1) coordinate is [-0.18992E+03]:   0.00'
    write(10,*) 'The number of versions for nj=2 is [1]:  1'
    write(10,*) 'The Xj(2) coordinate is [-0.15305E+03]:   50.00'
    write(10,*) 'The number of versions for nj=3 is [1]:  1'
    write(10,*) 'The Xj(3) coordinate is [-0.11340E+03]:   -150.00'
    close(10)	
  end subroutine write_node_file

  subroutine delete_node_file(NODEFILE)
    use other_consts, only: MAX_FILENAME_LEN 
    character(len=MAX_FILENAME_LEN), intent(out) :: NODEFILE  
    NODEFILE = "test.ipnode"
    open(10,file=NODEFILE, status="old")
    close(10, status="delete")     
  end subroutine delete_node_file

  subroutine set_nodes(nodes) 
    integer, intent(out) :: nodes(4)    
    nodes(1)=1
    nodes(2)=2
    nodes(3)=3
    nodes(4)=4    
  end subroutine set_nodes
  
  subroutine set_node_xyz(node_xyz)
    use arrays, only:dp
    real(dp),intent(out) :: node_xyz(3,4)
    node_xyz(1,1) = 0.0_dp
    node_xyz(2,1) = 0.0_dp
    node_xyz(3,1) = 0.0_dp
    node_xyz(1,2) = 0.0_dp 
    node_xyz(2,2) = 0.0_dp
    node_xyz(3,2) = -100.0_dp 
    node_xyz(1,3) = 0.0_dp
    node_xyz(2,3) = -50.0_dp
    node_xyz(3,3) = -150.0_dp
    node_xyz(1,4) = 0.0_dp
    node_xyz(2,4) = 50.0_dp
    node_xyz(3,4) = -150.0_dp  
  end subroutine set_node_xyz

!***************************************************

@Test
   subroutine test_define_1d_elements()
      use pfunit_mod
      use arrays,only: dp,num_elems,elem_nodes,elems_at_node,elem_cnct, &
           num_nodes,node_xyz,nodes,elem_field,elem_direction,elem_ordrs,maxgen
      use geometry,only: define_1d_elements	
      use indices, only: ne_length,num_ne,num_ord,perfusion_indices
      use other_consts, only: MAX_FILENAME_LEN
      implicit none

      character(len=MAX_FILENAME_LEN) :: ELEMFILE
      integer :: test_elem_nodes(2,3) !(2,num_elems)
      integer :: test_elems_at_node(4,0:3)    
      integer :: test_elem_cnct(-1:1,0:2,0:3) !array size: -1:1,0:2,0:num_elems    
      real(dp) :: test_elem_field(num_ne,3) !(num_ne,num_elems) 
      real(dp) :: test_elem_direction(3,3) !array size: 3,num_elems   
      integer :: test_elem_ordrs(num_ord,3) !array size: num_ord, num_elems 

      ELEMFILE = ""
      call write_elem_file(ELEMFILE)
          
      call define_1d_elements(ELEMFILE)
     
      !populate test variables - variables populated by sub define_1d_elements
      call set_elem_nodes(test_elem_nodes)
      call set_elems_at_node(test_elems_at_node)
      call set_elem_cnct(test_elem_cnct)  
      call set_elem_length(test_elem_field)
      call set_elem_direction(test_elem_direction) 
      call set_elem_ordrs(test_elem_ordrs)  
    
      @assertEqual(3, num_elems)
      @assertEqual(test_elem_nodes,elem_nodes)
      @assertEqual(test_elems_at_node,elems_at_node)
      @assertEqual(test_elem_cnct,elem_cnct)
      @assertEqual(test_elem_field,elem_field)
      @assertEqual(test_elem_direction,elem_direction)
      @assertEqual(test_elem_ordrs,elem_ordrs) 
      @assertEqual(2,maxgen)
      
      call delete_elem_file(ELEMFILE)
     
   end subroutine test_define_1d_elements

! subroutines which populate test data 
  subroutine write_elem_file(ELEMFILE)
    use other_consts, only: MAX_FILENAME_LEN
    character(len=MAX_FILENAME_LEN), intent(out) :: ELEMFILE  
    ELEMFILE = "test.ipelem"   
    open(10, file=ELEMFILE, status="replace")
    write(10,*) 'CMISS Version 2.1  ipelem File Version 2'
    write(10,*) 'Heading:'
    write(10,*) ''
    write(10,*) 'The number of elements is [1]: 3'
    write(10,*) ''
    write(10,*) 'Element number [    1]:  1'
    write(10,*) 'The number of geometric Xj-coordinates is [3]: 3'
    write(10,*) 'The basis function type for geometric variable 1 is [1]:  1'
    write(10,*) 'The basis function type for geometric variable 2 is [1]:  1'
    write(10,*) 'The basis function type for geometric variable 3 is [1]:  1'
    write(10,*) 'Enter the 2 global numbers for basis 1:  1  2'
    write(10,*) ''
    write(10,*) 'Element number [ 1002]:  2'
    write(10,*) 'The number of geometric Xj-coordinates is [3]: 3'
    write(10,*) 'The basis function type for geometric variable 1 is [1]:  1'
    write(10,*) 'The basis function type for geometric variable 2 is [1]:  1'
    write(10,*) 'The basis function type for geometric variable 3 is [1]:  1'
    write(10,*) 'Enter the 2 global numbers for basis 1:  2  3'
    write(10,*) ''
    write(10,*) 'Element number [ 1003]:  3'
    write(10,*) 'The number of geometric Xj-coordinates is [3]: 3'
    write(10,*) 'The basis function type for geometric variable 1 is [1]:  1'
    write(10,*) 'The basis function type for geometric variable 2 is [1]:  1'
    write(10,*) 'The basis function type for geometric variable 3 is [1]:  1'
    write(10,*) 'Enter the 2 global numbers for basis 1:  2  4'
    close(10)  
  end subroutine write_elem_file
  
  subroutine delete_elem_file(ELEMFILE)
    use other_consts, only: MAX_FILENAME_LEN
    character(len=MAX_FILENAME_LEN), intent(out) :: ELEMFILE  
    ELEMFILE = "test.ipelem"   
    open(10,file=ELEMFILE, status="old")
    close(10, status="delete") 
  end subroutine delete_elem_file
  
  subroutine set_elem_nodes(elem_nodes)
     integer,intent(out) :: elem_nodes(2,3)  
     elem_nodes(1,1)=1
     elem_nodes(2,1)=2
     elem_nodes(1,2)=2
     elem_nodes(2,2)=3
     elem_nodes(1,3)=2
     elem_nodes(2,3)=4
  end subroutine set_elem_nodes
  
  subroutine set_elems_at_node(elems_at_node)
     integer,intent(out) :: elems_at_node(4,0:3) !array size: num_nodes, 0:3
     elems_at_node=0
     elems_at_node(1,0)=1
     elems_at_node(1,1)=1
     elems_at_node(2,0)=3
     elems_at_node(2,1)=1
     elems_at_node(2,2)=2
     elems_at_node(2,3)=3
     elems_at_node(3,0)=1
     elems_at_node(3,1)=2
     elems_at_node(4,0)=1
     elems_at_node(4,1)=3    
  end subroutine set_elems_at_node
    
  subroutine set_elem_cnct(elem_cnct)
    integer,intent(out) :: elem_cnct(-1:1,0:2,0:3) !array size: -1:1,0:2,0:num_elems
    elem_cnct = 0
    elem_cnct(1,0,1)=2
    elem_cnct(1,1,1)=2
    elem_cnct(1,2,1)=3
    elem_cnct(-1,0,2)=1
    elem_cnct(-1,1,2)=1
    elem_cnct(-1,0,3)=1
    elem_cnct(-1,1,3)=1      
  end subroutine set_elem_cnct    
  
  subroutine set_elem_length(elem_field)
    use indices, only: ne_length,num_ne
    use arrays, only:dp
    real(dp),intent(inout) :: elem_field(num_ne,3) ! array size: num_ne, num_elems
    elem_field = 0.0_dp
    elem_field(ne_length,1) = 100.0_dp
    elem_field(ne_length,2) = 70.710678118654755_dp
    elem_field(ne_length,3) = 70.710678118654755_dp  
  end subroutine set_elem_length
  
  subroutine set_elem_direction(elem_direction)
    use arrays, only:dp
    real(dp),intent(out) :: elem_direction(3,3) !array size: 3,num_elems  
    elem_direction(1,1) = 0.0_dp
    elem_direction(2,1) = 0.0_dp
    elem_direction(3,1) = -1.0_dp
    elem_direction(1,2) = 0.0_dp
    elem_direction(2,2)= -0.70710678118654746_dp
    elem_direction(3,2) = -0.70710678118654746_dp
    elem_direction(1,3) = 0.0_dp
    elem_direction(2,3) = 0.70710678118654746_dp
    elem_direction(3,3) = -0.70710678118654746_dp  
  end subroutine set_elem_direction


  subroutine set_elem_ordrs(elem_ordrs)
    use indices, only: num_ord
    integer,intent(out) :: elem_ordrs(num_ord,3) !array size: num_ord, num_elems
    elem_ordrs(1,1) = 1
    elem_ordrs(2,1) = 2
    elem_ordrs(3,1) = 2
    elem_ordrs(1,2) = 2
    elem_ordrs(2,2) = 1
    elem_ordrs(3,2) = 1
    elem_ordrs(1,3) = 2
    elem_ordrs(2,3) = 1
    elem_ordrs(3,3) = 1 
  end subroutine set_elem_ordrs
  
!***************************************************
  
@Test

   subroutine test_append_units
      use pfunit_mod
      use arrays,only: num_units,units,elem_units_below
      use indices,only: num_nu
      use geometry, only:append_units
      implicit none

      integer :: test_units(2)
      integer :: test_elem_units_below(1:3) ! 1:num_elems
      
      call append_units()
    
      !populate test variables  
      call set_units(test_units)
      call set_elem_units_below(test_elem_units_below)
            
      @assertEqual(2, num_units)   
      @assertEqual(test_units,units)   
      @assertEqual(test_elem_units_below,elem_units_below)
            
   end subroutine test_append_units

!subroutines which populate test data 
  subroutine set_units(units)
    integer,intent(out) :: units(2)
    units(1)=2
    units(2)=3
  end subroutine set_units
   
  subroutine set_elem_units_below(elem_units_below)
    integer,intent(out) :: elem_units_below(1:3) ! 1:num_elems
    elem_units_below(1) = 2 
    elem_units_below(2) = 1 
    elem_units_below(3) = 1
  end subroutine set_elem_units_below

!***************************************************
   
@Test

   subroutine test_add_matching_mesh
      use pfunit_mod
      use arrays,only: dp,num_nodes,num_elems,nodes,node_xyz,elems,elem_nodes,&
                       elems_at_node,elem_field,elem_direction,elem_cnct,elem_ordrs                      
      use geometry, only:add_matching_mesh
      use indices, only: num_ord
      implicit none

      integer :: test_nodes(8) !arterial and venous num_nodes
      real(dp) :: test_node_xyz(3,8) !(3:num_nodes)
      integer :: test_elem_nodes(2,8) !(2:num_elems)
      integer :: test_elems_at_node(8,0:3) !array size: num_nodes, 0:3
      integer :: test_elem_cnct(-1:1,0:2,0:8) !array size: -1:1,0:2,0:num_elems
      integer :: test_elem_ordrs(num_ord,8) !array size: num_ord, num_elems
      
      call add_matching_mesh()
      
      !populate test variables
      call set_nodes(test_nodes(1:4)) !arterial num_nodes
      call set_nodes_ven(test_nodes(5:8)) !venous num_nodes
      call set_node_xyz(test_node_xyz(1:3,1:4))
      call set_node_xyz_ven(test_node_xyz(1:3,5:8))
      call set_elem_nodes(test_elem_nodes(1:2,1:3))
      call set_elem_nodes_ven(test_elem_nodes(1:2,4:8))
      call set_elems_at_node_new(test_elems_at_node)
      call set_elem_cnct_new(test_elem_cnct)
      call set_elem_ordrs(test_elem_ordrs(1:3,1:3))
      call set_elem_ordrs_ven(test_elem_ordrs(1:3,4:8))
      
      @assertEqual(8, num_nodes)
      @assertEqual(8, num_elems)
      @assertEqual(test_nodes, nodes)
      @assertEqual(test_node_xyz,node_xyz)
      @assertEqual(test_elem_nodes,elem_nodes)
      @assertEqual(test_elems_at_node,elems_at_node)
      @assertEqual(test_elem_cnct,elem_cnct)
      @assertEqual(test_elem_ordrs,elem_ordrs)
         
   end subroutine test_add_matching_mesh
   
   subroutine set_nodes_ven(nodes) 
    integer, intent(out) :: nodes(4)    
    nodes(1)=5
    nodes(2)=6
    nodes(3)=7
    nodes(4)=8    
   end subroutine set_nodes_ven
   
   subroutine set_node_xyz_ven(node_xyz)
    use arrays, only:dp
    real(dp),intent(out) :: node_xyz(3,4)
    node_xyz(1,1) = 0.0_dp
    node_xyz(2,1) = 9.9999999999999995E-007_dp
    node_xyz(3,1) = 0.0_dp
    node_xyz(1,2) = 0.0_dp 
    node_xyz(2,2) = 9.9999999999999995E-007_dp
    node_xyz(3,2) = -100.0_dp 
    node_xyz(1,3) = 0.0_dp
    node_xyz(2,3) = -49.999999000000003_dp
    node_xyz(3,3) = -150.0_dp
    node_xyz(1,4) = 0.0_dp
    node_xyz(2,4) = 50.000000999999997_dp
    node_xyz(3,4) = -150.0_dp  
  end subroutine set_node_xyz_ven
  
  subroutine set_elem_nodes_ven(elem_nodes)
     integer,intent(out) :: elem_nodes(2,5)  
     elem_nodes(1,1)=6
     elem_nodes(2,1)=5
     elem_nodes(1,2)=7
     elem_nodes(2,2)=6
     elem_nodes(1,3)=8
     elem_nodes(2,3)=6
     elem_nodes(1,4)=3
     elem_nodes(2,4)=7
     elem_nodes(1,5)=4
     elem_nodes(2,5)=8
  end subroutine set_elem_nodes_ven
  
  subroutine set_elems_at_node_new(elems_at_node)
     integer,intent(out) :: elems_at_node(8,0:3) !array size: num_nodes, 0:3
     elems_at_node=0
     elems_at_node(1,0)=1
     elems_at_node(1,1)=1
     elems_at_node(2,0)=3
     elems_at_node(2,1)=1
     elems_at_node(2,2)=2
     elems_at_node(2,3)=3
     elems_at_node(3,0)=2
     elems_at_node(3,1)=2
     elems_at_node(3,2)=7
     elems_at_node(4,0)=2
     elems_at_node(4,1)=3  
     elems_at_node(4,2)=8  
     elems_at_node(5,0)=1
     elems_at_node(5,1)=4     
     elems_at_node(6,0)=3
     elems_at_node(6,1)=4
     elems_at_node(6,2)=5
     elems_at_node(6,3)=6   
     elems_at_node(7,0)=2
     elems_at_node(7,1)=5  
     elems_at_node(7,2)=7
     elems_at_node(8,0)=2
     elems_at_node(8,1)=6  
     elems_at_node(8,2)=8      
  end subroutine set_elems_at_node_new
    
  subroutine set_elem_cnct_new(elem_cnct)
    integer,intent(out) :: elem_cnct(-1:1,0:2,0:8) !array size: -1:1,0:2,0:num_elems
    elem_cnct = 0
    elem_cnct(1,0,1)=2
    elem_cnct(1,1,1)=2
    elem_cnct(1,2,1)=3
    elem_cnct(-1,0,2)=1
    elem_cnct(-1,1,2)=1
    elem_cnct(1,0,2)=1
    elem_cnct(1,1,2)=7   
    elem_cnct(-1,0,3)=1
    elem_cnct(-1,1,3)=1    
    elem_cnct(1,0,3)=1
    elem_cnct(1,1,3)=8  
    elem_cnct(-1,0,4)=2
    elem_cnct(-1,1,4)=5 
    elem_cnct(-1,2,4)=6     
    elem_cnct(-1,0,5)=1
    elem_cnct(-1,1,5)=7  
    elem_cnct(1,0,5)=1
    elem_cnct(1,1,5)=4  
    elem_cnct(-1,0,6)=1
    elem_cnct(-1,1,6)=8 
    elem_cnct(1,0,6)=1
    elem_cnct(1,1,6)=4
    elem_cnct(-1,0,7)=1
    elem_cnct(-1,1,7)=2
    elem_cnct(1,0,7)=1
    elem_cnct(1,1,7)=5
    elem_cnct(-1,0,8)=1
    elem_cnct(-1,1,8)=3
    elem_cnct(1,0,8)=1
    elem_cnct(1,1,8)=6
  end subroutine set_elem_cnct_new    
  
  subroutine set_elem_ordrs_ven(elem_ordrs)
    use indices, only: num_ord
    integer,intent(out) :: elem_ordrs(num_ord,5)
    elem_ordrs(1,1) = 1
    elem_ordrs(2,1) = 2
    elem_ordrs(3,1) = 2
    elem_ordrs(1,2) = 2
    elem_ordrs(2,2) = 1
    elem_ordrs(3,2) = 1   
    elem_ordrs(1,3) = 2
    elem_ordrs(2,3) = 1
    elem_ordrs(3,3) = 1     
    elem_ordrs(1,4) = 2
    elem_ordrs(2,4) = 1
    elem_ordrs(3,4) = 1 
    elem_ordrs(1,5) = 2
    elem_ordrs(2,5) = 1
    elem_ordrs(3,5) = 1
  end subroutine set_elem_ordrs_ven
  
!***************************************************
  
@Test

  subroutine test_define_rad_from_geom
    use pfunit_mod
    use arrays,only: dp,elem_field,num_elems                     
    use geometry, only:define_rad_from_geom
    use indices, only: ne_radius,num_ne
    implicit none  
  
    character(LEN=100) :: order_system,order_options,name
    real(dp) :: s_ratio, inlet_rad
    real(dp) :: test_elem_field(num_ne,8) !(num_ne: num_elems)

    !define radius for arterial vessels
    order_system = "strahler"
    s_ratio=1.54_dp
    name = "inlet"
    inlet_rad=3.0_dp    
    order_options = "arterial"
    
    call define_rad_from_geom(order_system, s_ratio, name, inlet_rad, order_options,"")
    
    !define radius for venous vessels
    order_system = "strahler"
    s_ratio=1.55_dp
    name = ""
    inlet_rad=5.0_dp  
    order_options = "venous"
    call define_rad_from_geom(order_system, s_ratio, name, &
                    inlet_rad, order_options,"")
  
    call set_elem_radius(test_elem_field)
    
    @assertEqual(test_elem_field(ne_radius,1:8),elem_field(ne_radius,1:num_elems)) 
 
  end subroutine test_define_rad_from_geom

  subroutine set_elem_radius(elem_field)
    use arrays, only: dp
    use indices, only: ne_radius,num_ne
    real(dp),intent(out) :: elem_field(num_ne,8) !(num_ne : num_elems)
    
    elem_field = 0.0_dp
    elem_field(ne_radius,1)=3.0_dp   
    elem_field(ne_radius,2)=1.9480519480519483_dp    
    elem_field(ne_radius,3)=1.9480519480519483_dp    
    elem_field(ne_radius,4)=5.0000000000000009_dp
    elem_field(ne_radius,5)=3.2258064516129035_dp
    elem_field(ne_radius,6)=3.2258064516129035_dp
    elem_field(ne_radius,7)=3.2258064516129035_dp
    elem_field(ne_radius,8)=3.2258064516129035_dp
  end subroutine set_elem_radius
   



   